# blocked_orchestrator.py
"""
Blocked Nozzle Orchestrator — circle-ROI quadrant check (4×4 grid)
------------------------------------------------------------------
Purpose:
    Read an image → detect 16 nozzles → build per-nozzle circular ROIs →
    split into TL/TR/BL/BR quadrants → run `isBlockedHole` → return blocked names.

Quick use:
    from blocked_orchestrator import detect_blocked_nozzles, developerTest
    names = detect_blocked_nozzles(image_path, weights_path,
                                   imgsz=1280, conf=0.25, iou=0.5, pad_ratio=0.05)
    # → ['nozzle1TopLeft', 'nozzle7BottomRight', ...]
    # For visualization:
    dev = developerTest(image_path, weights_path, show=True, save_path=None)

Workflow:
    1) NozzleDetector.detect_16(img)  → 16 boxes (row-major, with cx, cy, R)
    2) Circle ROI per box (+ pad_ratio) → split 2×2 (TL, TR, BL, BR)
    3) `isBlockedHole(roi)` per quadrant → collect blocked labels
    4) `developerTest` draws bbox/circle/grid & overlays red/green by status

Key params:
    image_path (str), weights_path (str),
    imgsz (int), conf (float), iou (float), pad_ratio (float, circle padding)

Returns:
    - detect_blocked_nozzles: List[str] (e.g., ['nozzle3TopRight', ...])
    - developerTest: same list; also shows/saves annotated preview

Raises:
    FileNotFoundError, InvalidInputImageError
"""

from __future__ import annotations
from typing import List, Tuple
import os
import cv2
import numpy as np

from detector import NozzleDetector, InvalidInputImageError
from holecheck import isBlockedHole
from nozzle_types import NozzleBox

# DEV ONLY (สามารถคอมเมนต์ทิ้งได้)
# ========================= DEV BLOCK (safe to remove) =========================
# Realtime tuner + readable HUD + nozzle filter for developerTest only.
import holecheck
from holecheck import compute_hole_scores

_DEV_INIT = {"tuner_ready": False}

def _dev_init_tuner():
    """Create a trackbar window once."""
    if _DEV_INIT.get("tuner_ready", False):
        return
    cv2.namedWindow("Tuner", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("Tuner", 460, 260)
    def _nothing(x): pass
    # *100 scale for ratios and T
    cv2.createTrackbar("THRESH_T x100", "Tuner",
                       int(getattr(holecheck, "THRESH_T", 0.60)*100), 200, _nothing)
    cv2.createTrackbar("R_IN_RATIO x100", "Tuner",
                       int(getattr(holecheck, "R_IN_RATIO", 0.18)*100), 50, _nothing)
    cv2.createTrackbar("RING_W_RATIO x100", "Tuner",
                       int(getattr(holecheck, "RING_W_RATIO", 0.08)*100), 40, _nothing)
    cv2.createTrackbar("FOCUS_MIN", "Tuner",
                       int(getattr(holecheck, "FOCUS_MIN", 18.0)), 200, _nothing)
    cv2.createTrackbar("VERBOSE(0/1)", "Tuner", 0, 1, _nothing)
    # NEW: filter which nozzle’s HUD to show (0=All)
    cv2.createTrackbar("NOZZLE (0=All)", "Tuner", 0, 16, _nothing)
    # NEW: toggle HUD on/off quickly
    cv2.createTrackbar("HUD(0/1)", "Tuner", 1, 1, _nothing)
    _DEV_INIT["tuner_ready"] = True

def _dev_pull_tuner_values():
    """Read trackbar values and push to holecheck (used this frame)."""
    if not _DEV_INIT.get("tuner_ready", False):
        _dev_init_tuner()

    THRESH_T = cv2.getTrackbarPos("THRESH_T x100", "Tuner") / 100.0
    R_IN     = cv2.getTrackbarPos("R_IN_RATIO x100", "Tuner") / 100.0
    RING_W   = cv2.getTrackbarPos("RING_W_RATIO x100", "Tuner") / 100.0
    FOCUS    = float(cv2.getTrackbarPos("FOCUS_MIN", "Tuner"))
    VERBOSE  = int(cv2.getTrackbarPos("VERBOSE(0/1)", "Tuner")) > 0
    HUD_ON   = int(cv2.getTrackbarPos("HUD(0/1)", "Tuner")) > 0
    NZ_SEL   = int(cv2.getTrackbarPos("NOZZLE (0=All)", "Tuner"))

    # Clamp + apply to holecheck
    R_IN   = max(0.10, min(0.30, R_IN))
    RING_W = max(0.04, min(0.20, RING_W))
    FOCUS  = max(0.0,  min(200.0, FOCUS))
    THRESH_T = max(0.0, min(2.0, THRESH_T))

    holecheck.THRESH_T     = THRESH_T
    holecheck.R_IN_RATIO   = R_IN
    holecheck.RING_W_RATIO = RING_W
    holecheck.FOCUS_MIN    = FOCUS

    return dict(T=THRESH_T, r=R_IN, rw=RING_W, focus_min=FOCUS,
                verbose=VERBOSE, hud=HUD_ON, nz=NZ_SEL)

def _put_text_box(img, x, y, text, color=(255,255,255), bg=(0,0,0), alpha=0.55,
                  scale=0.7, thick=2):
    """Readable text with solid background box (no overlap issue)."""
    (tw, th), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, scale, thick)
    th = int(th * 1.15)
    pad = 4
    x2, y2 = x + tw + pad*2, y + th + pad*2
    x2 = min(x2, img.shape[1]-1); y2 = min(y2, img.shape[0]-1)
    overlay = img.copy()
    cv2.rectangle(overlay, (x, y), (x2, y2), bg, -1)
    cv2.addWeighted(overlay, alpha, img, 1-alpha, 0, img)
    cv2.putText(img, text, (x+pad, y+th+pad-2), cv2.FONT_HERSHEY_SIMPLEX, scale, color, thick, cv2.LINE_AA)
        
# (คง _dev_init_tuner, _dev_pull_tuner_values, _put_text_box ตามเดิม)

def _draw_nozzle_hud(vis, outer_rect, diags, statuses, tuner, nozzle_idx: int):
    """
    กล่อง HUD เดียวต่อหัว nozzle: 4 บรรทัด TL/TR/BL/BR
    outer_rect: (sx,sy,ex,ey), diags: [diag_TL, diag_TR, diag_BL, diag_BR], statuses: [bool]*4
    """
    H, W = vis.shape[:2]
    sx, sy, ex, ey = outer_rect
    max_line_w = 280
    box_w = max_line_w + 10
    x_right = ex + 8
    x_left  = max(0, sx - box_w - 8)
    anchor_x = x_right if (x_right + box_w < W) else x_left
    anchor_y = sy

    names = ["TL", "TR", "BL", "BR"]
    for i, name in enumerate(names):
        d = diags[i]
        s_ok = not statuses[i]
        col = (0,255,0) if s_ok else (0,0,255)
        s_val = 0.0 if d.get("S",-1) < 0 else d["S"]
        line = f"{name} {'OK' if s_ok else 'BLOCK'} | S={s_val:.2f} T={tuner['T']:.2f}"
        _put_text_box(
            vis, anchor_x, anchor_y + i*26, line,
            color=col, bg=(20,20,20), alpha=0.65, scale=0.75, thick=2
        )

    _put_text_box(vis, anchor_x, max(0, anchor_y-26),
                  f"# {nozzle_idx}", color=(255,255,0),
                  bg=(20,20,20), alpha=0.65, scale=0.75, thick=2)



def _resize_for_display(img: np.ndarray, max_w: int = 1200, max_h: int = 900) -> np.ndarray:
    H, W = img.shape[:2]
    scale = min(max_w / W, max_h / H, 1.0)
    if scale < 1.0:
        img = cv2.resize(img, (int(W*scale), int(H*scale)), interpolation=cv2.INTER_AREA)
    return img

def _blend_rect(img, x1, y1, x2, y2, color, alpha=0.28):
    overlay = img.copy()
    cv2.rectangle(overlay, (x1,y1), (x2,y2), color, -1)
    cv2.addWeighted(overlay, alpha, img, 1-alpha, 0, img)
# ======================= END DEV BLOCK (safe to remove) =======================


# ==========================================



# ลำดับควอดแรนท์สำหรับสร้างชื่อ
_QUAD_NAMES = ("TopLeft", "TopRight", "BottomLeft", "BottomRight")

def _analyze_nozzles(
    image_path: str,
    weights_path: str,
    *,
    imgsz: int,
    conf: float,
    iou: float,
    pad_ratio: float,
):
    """อ่านรูป → detect_16 → สร้าง ROI แบบ 'วงกลม' → คืน (img, boxes, quad_statuses)
       quad_statuses: List[List[bool]] ยาวเท่ากับ len(boxes), แต่ละตัวเป็น [TL,TR,BL,BR]
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found: {image_path}")
    img = cv2.imread(image_path)
    if img is None:
        raise FileNotFoundError(f"Failed to read image: {image_path}")

    det = NozzleDetector(weights_path, imgsz=imgsz, conf=conf, iou=iou)
    boxes = det.detect_16(img)  # อาจ raise InvalidInputImageError

    quad_statuses: List[List[bool]] = []
    for box in boxes:
        quads, _ = _crop_circle_quadrants(img, box, pad_ratio=pad_ratio)  # [TL,TR,BL,BR]
        statuses = []
        for roi in quads:
            try:
                statuses.append(bool(isBlockedHole(roi)))
            except Exception:
                statuses.append(False)
        quad_statuses.append(statuses)
    return img, boxes, quad_statuses

def _crop_circle_quadrants(img: np.ndarray, box: NozzleBox, pad_ratio: float = 0.05) -> Tuple[List[np.ndarray], Tuple[int,int,int,int]]:
    """
    คืน ROIs 4 ชิ้น โดยอ้างอิง 'วงกลม' ของ nozzle:
      - สร้าง bounding square รอบวงกลม (ใช้ cx,cy,R หรือประมาณจาก bbox)
      - แบ่ง 2×2 เป็น TL,TR,BL,BR
      - ทำ 'mask วงกลม' ให้แต่ละชิ้น (นอกวงกลมถูกทำให้ดำ)
    return: ([TL,TR,BL,BR], (sx,sy,ex,ey))  // พิกัดสี่เหลี่ยมล้อมวงกลมสำหรับวาดเส้นแบ่ง
    """
    H, W = img.shape[:2]
    # ใช้ cx,cy,R ถ้ามี ไม่งั้นประมาณจาก bbox
    x1, y1, x2, y2 = map(int, (box.x1, box.y1, box.x2, box.y2))
    w = x2 - x1; h = y2 - y1
    cx = int((x1 + x2) / 2) if box.cx is None else int(box.cx)
    cy = int((y1 + y2) / 2) if box.cy is None else int(box.cy)
    R  = int(0.4 * min(w, h)) if (box.R is None or box.R <= 0) else int(box.R)
    R  = max(8, R)

    # padding ตามสัดส่วนรัศมี (ไม่ใช้ bbox แล้ว)
    pr = int(R * pad_ratio)
    r_pad = R + pr

    sx = max(0, cx - r_pad); ex = min(W, cx + r_pad)
    sy = max(0, cy - r_pad); ey = min(H, cy + r_pad)
    if ex <= sx or ey <= sy:
        # fallback: ใช้ bbox
        sx, sy, ex, ey = x1, y1, x2, y2

    patch = img[sy:ey, sx:ex].copy()
    if patch.size == 0:
        return [np.zeros((1,1,3), dtype=np.uint8)]*4, (sx,sy,ex,ey)

    # พิกัดวงกลมในพิกเซลของ patch
    pcx = cx - sx
    pcy = cy - sy

    # แบ่งควอดแรนท์ใน patch สี่เหลี่ยมนี้
    H2, W2 = patch.shape[:2]
    mx = W2 // 2
    my = H2 // 2
    quads_rect = [
        (0,   0,   mx,  my),   # TL
        (mx,  0,   W2,  my),   # TR
        (0,   my,  mx,  H2),   # BL
        (mx,  my,  W2,  H2),   # BR
    ]

    out_quads: List[np.ndarray] = []
    # ทำ mask วงกลมให้แต่ละชิ้น
    for (qx1, qy1, qx2, qy2) in quads_rect:
        quad = patch[qy1:qy2, qx1:qx2].copy()
        qH, qW = quad.shape[:2]
        mask = np.zeros((qH, qW), dtype=np.uint8)

        # วาดวงกลมบน mask—ต้องชิฟต์ศูนย์กลางให้สัมพันธ์กับ quad ย่อย
        local_cx = pcx - qx1
        local_cy = pcy - qy1
        # รัศมีในพื้นที่ quad อาจโดนตัดขอบ—ใช้ R เดิมแต่ส่วนที่เกินจะไม่อยู่ในภาพอยู่แล้ว
        cv2.circle(mask, (int(local_cx), int(local_cy)), int(R), 255, thickness=-1)

        # apply mask (bitwise_and) → นอกวงกลมเป็นดำ
        quad_masked = cv2.bitwise_and(quad, quad, mask=mask)
        out_quads.append(quad_masked)

    return out_quads, (sx, sy, ex, ey)


def detect_blocked_nozzles(
    image_path: str,
    weights_path: str,
    *,
    imgsz: int = 1280,
    conf: float = 0.25,
    iou: float = 0.5,
    pad_ratio: float = 0.05,
) -> List[str]:
    """
    ใช้ ROI แบบ 'วงกลม' → คืนรายชื่อที่ตัน เช่น ["nozzle1TopLeft", ...]
    """
    img, boxes, quad_statuses = _analyze_nozzles(
        image_path, weights_path, imgsz=imgsz, conf=conf, iou=iou, pad_ratio=pad_ratio
    )

    blocked_names: List[str] = []
    for box, statuses in zip(boxes, quad_statuses):
        nozzle_num = int(box.grid_index) + 1
        for q_idx, is_blocked in enumerate(statuses):
            if is_blocked:
                blocked_names.append(f"nozzle{nozzle_num}{_QUAD_NAMES[q_idx]}")
    return blocked_names


# ===== Developer visual test ===== comment after finish
def developerTest(
    image_path: str,
    weights_path: str,
    * ,
    imgsz: int = 1280,
    conf: float = 0.25,
    iou: float = 0.5,
    pad_ratio: float = 0.05,
    show: bool = True,
    wait_ms: int = 0,          # ไม่ใช้แล้วในโหมด realtime แต่คงพารามิเตอร์ไว้
    save_path: str | None = None,
) -> List[str]:
    """
    Realtime tuning with trackbars:
      - THRESH_T, R_IN_RATIO, RING_W_RATIO, FOCUS_MIN, VERBOSE
      - NOZZLE(0=All,1–16) to show HUD of one nozzle
    Press SPACE/ENTER -> return results; Q/ESC -> abort returning current.
    """
    # 1) init tuner + read values once
    _dev_init_tuner()
    tuner = _dev_pull_tuner_values()

    # 2) detect ONCE (reuse boxes); crop quads & store rects for speed
    img0 = cv2.imread(image_path)
    if img0 is None:
        raise FileNotFoundError(f"Failed to read image: {image_path}")
    det = NozzleDetector(weights_path, imgsz=imgsz, conf=conf, iou=iou)
    boxes = det.detect_16(img0)

    # Precompute quads and rects per nozzle
    per_nozzle_quads  = []
    per_nozzle_rects  = []
    per_nozzle_outer  = []
    for box in boxes:
        quads, (sx, sy, ex, ey) = _crop_circle_quadrants(img0, box, pad_ratio=pad_ratio)
        mx, my = (sx+ex)//2, (sy+ey)//2
        rects = [(sx,sy,mx,my), (mx,sy,ex,my), (sx,my,mx,ey), (mx,my,ex,ey)]
        per_nozzle_quads.append(quads)
        per_nozzle_rects.append(rects)
        per_nozzle_outer.append((sx, sy, ex, ey))



    blocked_names: List[str] = []

    # 3) realtime loop (re-evaluate with current tuner values)
    while True:
        tuner = _dev_pull_tuner_values()  # read updated sliders

        vis = img0.copy()
        green = (60,200,60); red=(0,0,255); cyan=(255,200,0); yellow=(0,220,255); white=(255,255,255)

        blocked_names = []  # recompute every frame

        # Which nozzle to show HUD? (0=All)
        nz_sel = tuner["nz"]  # 0..16
        show_all = (nz_sel == 0)

        for idx, (box, quads, rects) in enumerate(zip(boxes, per_nozzle_quads, per_nozzle_rects), start=1):
            x1, y1, x2, y2 = map(int, (box.x1, box.y1, box.x2, box.y2))
            # draw bbox & circle (always)
            cv2.rectangle(vis, (x1,y1), (x2,y2), cyan, 2)
            cv2.putText(vis, f"#{idx}", (x1, max(0,y1-8)), cv2.FONT_HERSHEY_SIMPLEX, 0.7, cyan, 2, cv2.LINE_AA)
            w = x2 - x1; h = y2 - y1
            cx = int((x1 + x2)/2) if box.cx is None else int(box.cx)
            cy = int((y1 + y2)/2) if box.cy is None else int(box.cy)
            R  = int(0.4*min(w,h)) if (box.R is None or box.R <= 0) else int(box.R)
            R  = max(8, R)
            cv2.circle(vis, (cx,cy), R, yellow, 2)

            # evaluate statuses with current holecheck params
            statuses = []
            for q in quads:
                try:
                    statuses.append(bool(isBlockedHole(q)))
                except Exception:
                    statuses.append(False)

            # paint status overlays (เดิม)
            for qi, rect in enumerate(rects):
                (sx,sy,ex,ey) = rect
                _blend_rect(vis, sx, sy, ex, ey, red if statuses[qi] else green)

            # HUD แบบเดียว: กล่องรวม 4 บรรทัด ต่อหัว
            try:
                diags = [compute_hole_scores(q) for q in quads]   # ใช้ quads ที่ precompute แล้ว
                outer = per_nozzle_outer[idx-1]                   # (sx,sy,ex,ey) ที่เก็บไว้
                # แสดงทุกหัว ถ้า NOZZLE=0; ไม่งั้นแสดงเฉพาะหัวที่เลือก
                if tuner["hud"] and (tuner["nz"] == 0 or idx == tuner["nz"]):
                    _draw_nozzle_hud(vis, outer, diags, statuses, tuner, idx)
            except Exception:
                pass




            # collect names
            for q_idx, is_blocked in enumerate(statuses):
                if is_blocked:
                    blocked_names.append(f"nozzle{idx}{_QUAD_NAMES[q_idx]}")

        # show/save
        if save_path:
            os.makedirs(os.path.dirname(save_path), exist_ok=True)
            cv2.imwrite(save_path, vis)

        if show:
            vis_show = _resize_for_display(vis, max_w=1000, max_h=800)
            cv2.imshow("developerTest", vis_show)

        # realtime: poll keys quickly
        k = cv2.waitKey(1) & 0xFF  # 1 ms
        if k in (27, ord('q'), ord('Q')):   # ESC or Q -> exit
            break
        if k in (13, 10, 32):  # ENTER/RETURN/SPACE -> accept & continue
            break

    return blocked_names



# ===== ตัวอย่างการใช้งานจาก main (เรียก developerTest แทน detect_blocked_nozzles) =====
if __name__ == "__main__":
    import glob, os

    weights = r"C:\Project\nozzleScan\NozzleCleanerProject\best.pt"
    folder  = r"C:\Project\nozzleScan\NozzleCleanerProject\pictures"  # โฟลเดอร์ภาพ
    # save_dir = "out"  # โฟลเดอร์เซฟผล annotate

    # เอาไฟล์ที่เป็นนามสกุลรูป
    exts = (".jpg", ".jpeg", ".png", ".bmp", ".webp")
    pictures = [f for f in glob.glob(os.path.join(folder, "*")) if f.lower().endswith(exts)]
    pictures.sort()  # เรียงชื่อไฟล์

    try:
        for pic in pictures:
            fname = os.path.basename(pic)
            # save_path = os.path.join(save_dir, fname)

            result = developerTest(
                pic, weights,
                imgsz=1280, conf=0.25, iou=0.5, pad_ratio=0.05,
                show=True, wait_ms=0,          # กดปุ่มใดๆ เพื่อดูภาพต่อไป
                # save_path=save_path            # เซฟภาพ annotate ทีละไฟล์
            )
            print(f"{fname} -> {result}")       # ตอนนี้คาดว่า []
    except InvalidInputImageError as e:
        print("Invalid image:", e)
    except FileNotFoundError as e:
        print(e)
